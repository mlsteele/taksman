#!/usr/bin/env python
""" Assignment management tool for school.
Usage:
  taksman (-h | --help)
  taksman add <entry>
  taksman edit <entry>
  taksman done <entry>
  taksman all
  taksman course
  taksman due
  taksman debug

Examples:
  taksman add 033-reading   create a new task entry
  taksman done <entry>      mark an entry as done
  taksman all               list all tasks entries
  taksman due               list tasks organized by due date

Options:
  -h, --help
"""

import sys
import os
import errno
import subprocess
import re
import shutil
import inspect
import filecmp
import dateutil.parser
import datetime
import dateutil.relativedelta
from pprint import pprint
from docopt import docopt
import humanize

class TaskReadError(Exception):
    def __init__(self, msg):
        self.msg = msg

def show_all(tasks):
    names = sorted(tasks.keys())

    print "All tasks:"
    for name in names:
        print "> %s" % name
        body = tasks[name]['body'].strip()
        if body:
            print "   %s" % body.replace("\n", "\n   ")
        for field in tasks[name].keys():
            val = str(tasks[name][field]).strip()
            if field != 'body' and val:
                print "   %s: %s" % (field, val)

def show_by_course(tasks):
    courses = set(tasks[name].get('course') for name in tasks)
    # Note: None can be in this set
    # courses -= set([None])
    courses = sorted(courses)

    for course in courses:
        print
        print "Course: %s" % course
        course_tasks = task_filter(tasks, 'course', course)
        for name in course_tasks:
            print "> %s" % name

def show_by_due(tasks):
    dates = set(tasks[name].get('due') for name in tasks)
    dates.discard(None)
    dates = sorted(dates)

    print "No due date:"
    no_date_tasks = task_filter(tasks, 'due', None)
    for name in no_date_tasks:
        print "> %s" % name

    for date in dates:
        print
        print "Due %s:" % format_date(date)
        date_tasks = task_filter(tasks, 'due', date)
        for name in date_tasks:
            print "> %s" % name

def read_tasks(db_root):
    """ Load tasks from db. """
    entry_names = os.listdir(os.path.join(db_root, "entry"))
    entry_paths = {filename: os.path.join(db_root, "entry", filename) for filename in entry_names}
    tasks = {}
    for name in entry_names:
        try:
            tasks[name] = read_task(entry_paths[name])
        except TaskReadError as e:
            print "%s in task '%s'" % (e.msg, name)
            print "run `taksman edit %s` to fix the problem." % name
            sys.exit(-1)
    return tasks

def read_task(filepath):
    """ Read a task from a file. """
    task = {}
    task['body'] = ""

    with open(filepath, 'r') as f:
        reading_headers = True
        for line in f.readlines():
            comment_match = re.match(r"\s*#.*", line)
            blankline_match = re.match(r"\s*$", line)
            if comment_match or blankline_match:
                continue
            header_match = re.match(r"(?P<field>\w+): +(?P<value>.*)$", line)
            if reading_headers and header_match:
                field = header_match.group('field')
                value = header_match.group('value')
                assert field != 'body'
                assert field != 'date'
                assert field not in task
                if field == 'due':
                    try:
                        task[field] = dateutil.parser.parse(value)
                    except ValueError:
                        raise TaskReadError("Unreadable due date")
                else:
                    task[field] = value.rstrip()
            else:
                reading_headers = False
                task['body'] += line.rstrip() + "\n"

    task['body'] = task['body'].rstrip()

    return task

def ensure_db(db_root):
    """ Make the storage directories exist. """
    mkdir_p(os.path.join(db_root, "entry"))
    mkdir_p(os.path.join(db_root, "done"))
    mkdir_p(os.path.join(db_root, "template"))
    
    # add or update template
    default_template_path = os.path.join(db_root, "template", "default_template") 
    template_source_dir = os.path.dirname(os.path.abspath(inspect.getfile(inspect.currentframe())))
    template_source_path = os.path.join(template_source_dir, "default_template")
    if not os.path.isfile(template_source_path):
        print "default_template file missing"
        sys.exit(-1)
    if not os.path.isfile(default_template_path): 
        shutil.copyfile(template_source_path, default_template_path)
    elif not filecmp.cmp(default_template_path, template_source_path):
        r = raw_input("Your default template is not the same as mine. Do you want to update yours? [Yn] ")
        if r.lower() != "n":
            shutil.copyfile(template_source_path, default_template_path)

def task_filter(tasks, key, value):
    """ Get the tasks for which key = value. """
    return filter(
        lambda name: tasks[name].get(key) == value,
        tasks)

def mkdir_p(path):
    """ no error if existing, make parent directories as needed """
    try:
        os.makedirs(path)
    except OSError as exc:
        if exc.errno == errno.EEXIST and os.path.isdir(path):
            pass
        else:
            raise

def edit_file(filepath):
    editor = os.environ.get('EDITOR', 'nano')
    subprocess.call([editor, filepath])

def format_date(date):
    """ Format a pretty human readable date. """
    # http://stackoverflow.com/questions/6574329/how-can-i-produce-a-human-readable-difference-when-subtracting-two-unix-timestam
    now = datetime.datetime.now()
    past = now > date
    rd = dateutil.relativedelta.relativedelta(date, now)
    attrs = ['years', 'months', 'days', 'hours', 'minutes', 'seconds']
    human_readable_dt = lambda delta: ['%d %s' % (getattr(delta, attr), getattr(delta, attr) > 1 and attr or attr[:-1]) 
        for attr in attrs if getattr(delta, attr)]
    rel = human_readable_dt(rd)[0]
    day_str = humanize.naturaldate(date).capitalize()
    if past:
        return "%s (PAST)" % (day_str)
    else:
        return "%s (%s)" % (day_str, rel)

if __name__ == "__main__":
    db_root = os.path.expanduser("~/.taksman")
    template = os.path.join(db_root, 'template', "default_template")
    ensure_db(db_root)

    arguments = docopt(__doc__)
    if arguments['debug']:
        tasks = read_tasks(db_root)
        pprint(tasks)
    elif arguments['add']:
        tasks = read_tasks(db_root)
        name = arguments['<entry>']
        if name in tasks:
            print "%s already in tasks" % name
            sys.exit(-1)
        filepath = os.path.join(db_root, 'entry', name)
        shutil.copyfile(template, filepath)
        edit_file(filepath)
        print "%s saved to %s" % (name, filepath)
    elif arguments['edit']:
        name = arguments['<entry>']
        filepath = os.path.join(db_root, 'entry', name)
        edit_file(filepath)
        print "changes saved to %s" % filepath
    elif arguments['done']:
        tasks = read_tasks(db_root)
        name = arguments['<entry>']
        if name not in tasks:
            print "%s not in tasks" % name
            sys.exit(-1)
        filepath = os.path.join(db_root, 'entry', name)
        newpath = os.path.join(db_root, 'done', name)
        os.rename(filepath, newpath)
        print "%s archived to %s" % (name, newpath)
    elif arguments['all']:
        tasks = read_tasks(db_root)
        show_all(tasks)
    elif arguments['course']:
        tasks = read_tasks(db_root)
        show_by_course(tasks)
    elif arguments['due']:
        tasks = read_tasks(db_root)
        show_by_due(tasks)
    else:
        print "Whoops, unhandled input."
        sys.exit(-1)

    sys.exit(0)
